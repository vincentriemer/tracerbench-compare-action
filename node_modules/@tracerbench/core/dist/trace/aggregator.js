"use strict";
// tslint:disable:member-ordering
Object.defineProperty(exports, "__esModule", { value: true });
function verifyMethods(array) {
    const valuesSoFar = [];
    for (let i = 0; i < array.length; ++i) {
        const { functionName, moduleName } = array[i];
        const key = `${functionName}${moduleName}`;
        if (valuesSoFar.includes(key)) {
            throw new Error(`Duplicate heuristic detected ${moduleName}@${functionName}`);
        }
        valuesSoFar.push(key);
    }
}
exports.verifyMethods = verifyMethods;
function categorizeAggregations(aggregations, categories) {
    const categorized = {
        unknown: [aggregations.unknown],
    };
    Object.keys(categories).forEach(category => {
        if (!categorized[category]) {
            categorized[category] = [];
        }
        Object.values(aggregations).forEach(aggergation => {
            if (categories[category].find(locator => locator.functionName === aggergation.functionName &&
                locator.moduleName === aggergation.moduleName)) {
                categorized[category].push(aggergation);
            }
        });
    });
    return categorized;
}
exports.categorizeAggregations = categorizeAggregations;
class AggregrationCollector {
    constructor(locators, archive, hierarchy, modMatcher) {
        this.aggregations = {};
        this.parsedFiles = {};
        this.locators = locators;
        this.archive = archive;
        this.hierarchy = hierarchy;
        this.modMatcher = modMatcher;
        locators.forEach(({ functionName, moduleName }) => {
            this.aggregations[functionName + moduleName] = {
                total: 0,
                self: 0,
                attributed: 0,
                functionName,
                moduleName,
                callframes: [],
            };
        });
        this.aggregations.unknown = {
            total: 0,
            self: 0,
            attributed: 0,
            functionName: 'unknown',
            moduleName: 'unknown',
            callframes: [],
        };
    }
    pushCallFrames(name, callFrame) {
        this.aggregations[name].callframes.push(callFrame);
    }
    addToAttributed(name, time) {
        this.aggregations[name].attributed += time;
    }
    addToTotal(name, time) {
        this.aggregations[name].total += time;
    }
    collect() {
        Object.keys(this.aggregations).forEach(method => {
            const { callframes } = this.aggregations[method];
            this.aggregations[method].self = callframes.reduce((a, c) => a + c.self, 0);
        });
        return this.aggregations;
    }
    match(callFrame) {
        return this.locators.find(locator => {
            // try to avoid having to regex match is there are .* entries
            const sameFN = locator.functionName === callFrame.functionName;
            if (locator.moduleName === '.*' && sameFN) {
                return true;
            }
            if (this.isBuiltIn(callFrame)) {
                return false;
            }
            const callFrameModuleName = this.modMatcher.findModuleName(callFrame);
            if (callFrameModuleName === undefined) {
                return false;
            }
            // try to avoid having to regex match is there are .* entries
            const sameMN = locator.moduleName === callFrameModuleName;
            if (sameMN && locator.functionName === '.*') {
                return true;
            }
            if (sameFN && sameMN) {
                return true;
            }
            // if nothing else matches, do full regex check
            const sameFNRegex = locator.functionNameRegex.test(callFrame.functionName);
            const sameMNRegex = locator.moduleNameRegex.test(callFrameModuleName);
            return sameFNRegex && sameMNRegex;
        });
    }
    isBuiltIn(callFrame) {
        const { url, lineNumber } = callFrame;
        if (url === undefined) {
            return true;
        }
        if (url === 'extensions::SafeBuiltins') {
            return true;
        }
        if (url === 'v8/LoadTimes') {
            return true;
        }
        if (url === 'native array.js') {
            return true;
        }
        if (url === 'native intl.js') {
            return true;
        }
        if (lineNumber === -1 || lineNumber === undefined) {
            return true;
        }
        return false;
    }
}
function collapseCallFrames(aggregations) {
    Object.keys(aggregations).forEach(methodName => {
        const collapsed = [];
        const keys = [];
        aggregations[methodName].callframes.forEach(callframeInfo => {
            const key = callframeInfo.stack.reduce((acc, cur) => {
                const { functionName, columnNumber, lineNumber } = cur;
                return (acc += `${functionName}${columnNumber}${lineNumber}`);
            }, '');
            if (!keys.includes(key)) {
                keys.push(key);
                collapsed.push(callframeInfo);
            }
        });
        aggregations[methodName].callframes = collapsed;
    });
    return aggregations;
}
exports.collapseCallFrames = collapseCallFrames;
function aggregate(hierarchy, locators, archive, modMatcher) {
    const aggregations = new AggregrationCollector(locators, archive, hierarchy, modMatcher);
    hierarchy.each((node) => {
        const { self } = node.data;
        if (self !== 0) {
            let currentNode = node;
            const stack = [];
            let containerNode = null;
            while (currentNode) {
                const canonicalLocator = aggregations.match(currentNode.data.callFrame);
                if (canonicalLocator) {
                    const { functionName: canonicalizeName, moduleName: canonicalizeModName, } = canonicalLocator;
                    if (!containerNode) {
                        aggregations.addToAttributed(canonicalizeName + canonicalizeModName, self);
                        aggregations.pushCallFrames(canonicalizeName + canonicalizeModName, { self, stack });
                        containerNode = currentNode;
                    }
                    aggregations.addToTotal(canonicalizeName + canonicalizeModName, self);
                }
                stack.push(currentNode.data.callFrame);
                currentNode = currentNode.parent;
            }
            if (!containerNode) {
                aggregations.addToAttributed('unknown', self);
                aggregations.addToTotal('unknown', self);
                aggregations.pushCallFrames('unknown', { self, stack });
            }
        }
    });
    return aggregations.collect();
}
exports.aggregate = aggregate;
//# sourceMappingURL=aggregator.js.map