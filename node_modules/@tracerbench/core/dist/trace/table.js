"use strict";
/* tslint:disable:max-classes-per-file */
Object.defineProperty(exports, "__esModule", { value: true });
class Cell {
    constructor(content) {
        this.content = content;
    }
    pad(size, dir) {
        const { content } = this;
        switch (dir) {
            case 'left':
                this.content = `${new Array(size + 1).join(' ')}${content}`;
                break;
            case 'right':
                this.content = `${content}${new Array(size + 1).join(' ')}`;
                break;
        }
    }
    size() {
        return this.content.length;
    }
    toString() {
        return this.content;
    }
}
class Row {
    constructor(divider) {
        this.divider = divider;
        this.cells = [];
    }
    addCell(content) {
        const cell = new Cell(content);
        this.cells.push(cell);
        return cell;
    }
    size() {
        return this.toString().length;
    }
    cellSizes() {
        return this.cells.map(c => c.size());
    }
    fit(maxCellSizes) {
        const cellSizes = this.cellSizes();
        if (!this.divider) {
            cellSizes.forEach((size, i) => {
                const amount = maxCellSizes[i] - size;
                this.cells[i].pad(amount, 'right');
            });
        }
    }
    empty() {
        this.addCell('');
    }
    fill(size) {
        const content = new Array(size + 1).join(this.divider);
        this.cells.push(new Cell(content));
    }
    toString() {
        return this.cells.join('');
    }
}
class Table {
    constructor() {
        this.rows = [];
    }
    addRow(divider) {
        const row = new Row(divider);
        this.rows.push(row);
        return row;
    }
    toString() {
        const { rows } = this;
        const maxCellSizes = this.maxCellSizes();
        rows.forEach(row => {
            if (!row.divider) {
                row.fit(maxCellSizes);
            }
        });
        const rowLength = this.maxRowSize();
        rows.forEach(row => {
            if (row.divider) {
                row.fill(rowLength);
            }
        });
        return rows.join('\n');
    }
    maxRowSize() {
        let maxRowSize = 0;
        const { rows } = this;
        rows.forEach(row => {
            const len = row.size();
            if (len > maxRowSize) {
                maxRowSize = len;
            }
        });
        return maxRowSize;
    }
    maxCellSizes() {
        const maxCellSizes = [];
        const { rows } = this;
        rows.forEach(row => {
            const cellSizes = row.cellSizes();
            cellSizes.forEach((col, i) => {
                if (!maxCellSizes[i] || col > maxCellSizes[i]) {
                    maxCellSizes[i] = col;
                }
            });
        });
        return maxCellSizes;
    }
}
exports.Table = Table;
//# sourceMappingURL=table.js.map