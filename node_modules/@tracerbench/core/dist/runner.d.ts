export interface IBenchmark<State, Result> {
    name: string;
    /** convenience to run the benchmark, returning result */
    run(iterations: number): Promise<Result>;
    /** alternatively, the following can be invoked manually in order */
    /** setup the benchmark */
    setup(): Promise<State>;
    /** run a single iteration of the benchmark */
    perform(state: State, iteration: number): Promise<State>;
    /** finalize the benchmark, returning result */
    finalize(state: State): Promise<Result>;
    dispose(): Promise<void>;
}
export declare class Runner<R, S> {
    private benchmarks;
    constructor(benchmarks: Array<IBenchmark<S, R>>);
    /**
     * Shuffle when to run the benchmarks
     *
     * @param iterations - Number of iterations to run for each Benchmark
     * @param logger - If CLI command is using this, a log function (this.log) can be passed and will be used to indicate progress
     */
    run(iterations: number, logger?: (msg: string) => void): Promise<R[]>;
    private inSequence;
    private shuffled;
}
//# sourceMappingURL=runner.d.ts.map