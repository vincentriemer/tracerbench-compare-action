"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chrome_debugging_client_1 = require("chrome-debugging-client");
const race_cancellation_1 = require("race-cancellation");
const os = require("os");
const runner_1 = require("./runner");
const tab_1 = require("./tab");
class Benchmark {
    constructor(params) {
        this.name = params.name;
        this.browserOptions = params.browser;
        this.delay = params.delay === undefined ? 800 : params.delay;
    }
    async run(iterations) {
        const benchmarks = [this];
        const runner = new runner_1.Runner(benchmarks);
        const result = await runner.run(iterations);
        return result[0];
    }
    // create session, spawn browser, get port connect to API to get version
    async setup() {
        const browserOptions = this.browserOptions;
        const process = (this.process = chrome_debugging_client_1.spawnChrome(browserOptions));
        const browser = process.connection;
        const { targetId } = await browser.send('Target.createTarget', {
            url: 'about:blank',
        });
        const tab = await browser.attachToTarget(targetId);
        if (!tab) {
            throw Error('failed to attach to target');
        }
        // close other page targets
        const { targetInfos } = await browser.send('Target.getTargets');
        for (const targetInfo of targetInfos) {
            if (targetInfo.type === 'page' && targetInfo.targetId !== targetId) {
                await browser.send('Target.closeTarget', {
                    targetId: targetInfo.targetId,
                });
            }
        }
        await race_cancellation_1.sleep(1500, tab.raceDetached);
        const browserMeta = await browser.send('Browser.getVersion');
        const browserProduct = browserMeta.product;
        const cpus = os.cpus().map(cpu => cpu.model);
        const results = this.createResults({
            browserVersion: browserProduct,
            cpus,
        });
        const state = { process, browser, tab, results };
        await this.withTab(state, t => this.warm(t));
        return state;
    }
    async perform(state, iteration) {
        await this.withTab(state, tab => this.performIteration(tab, state.results, iteration));
        return state;
    }
    async finalize(state) {
        const { process: chrome, browser, results } = state;
        if (!chrome.hasExited) {
            await browser.send('Browser.close');
            await chrome.waitForExit();
        }
        return results;
    }
    async dispose() {
        const process = this.process;
        if (process !== undefined) {
            await process.dispose();
        }
    }
    async warm(_) {
        // noop
    }
    async withTab(state, callback) {
        const browser = state.browser;
        const tab = state.tab;
        await tab.send('Page.enable');
        const res = await tab.send('Page.getResourceTree');
        const frame = res.frameTree.frame;
        const dsl = tab_1.default(tab.targetId, browser, tab, frame);
        await dsl.clearBrowserCache();
        await dsl.collectGarbage();
        await browser.send('Target.activateTarget', { targetId: tab.targetId });
        await race_cancellation_1.sleep(this.delay, tab.raceDetached);
        await browser.send('Target.activateTarget', { targetId: tab.targetId });
        const rtn = await callback(dsl);
        state.tab = await browser.attachToTarget(await browser.send('Target.createTarget', { url: 'about:blank' }));
        await browser.send('Target.closeTarget', { targetId: tab.targetId });
        return rtn;
    }
}
exports.Benchmark = Benchmark;
//# sourceMappingURL=benchmark.js.map