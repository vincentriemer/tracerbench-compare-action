"use strict";
/* tslint:disable:no-console*/
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const logSymbols = require("log-symbols");
/**
 * Handles checking if there is a specific override for the attributeName in the tbConfigs for the given overrideObjectName.
 * Defaults to whatever is in the flags object if there is no override.
 *
 * @param attributeName - Attribute name to check if there is an override in overrideObjectName from tbConfig
 * @param flags - Object containing configs parsed from the Command class
 * @param overrideObjectName - Either "controlBenchmarkEnvironment" or "experimentBenchmarkEnvironment"
 * @param tbConfig - This refers to the parsed JSON from the config file if it exists
 */
function checkEnvironmentSpecificOverride(attributeName, flags, overrideObjectName, tbConfig) {
    if (!tbConfig || !tbConfig[overrideObjectName]) {
        return flags[attributeName];
    }
    const environmentSpecificConfigs = tbConfig[overrideObjectName];
    if (!environmentSpecificConfigs[attributeName]) {
        return flags[attributeName];
    }
    return environmentSpecificConfigs[attributeName];
}
exports.checkEnvironmentSpecificOverride = checkEnvironmentSpecificOverride;
/**
 * Merge the contents of the right object into the left. Simply replace numbers, strings, arrays
 * and recursively call this function with objects.
 *
 * Note that typeof null == 'object'
 *
 * @param left - Destination object
 * @param right - Content of this object takes precedence
 */
function mergeLeft(left, right) {
    Object.keys(right).forEach(key => {
        const leftValue = left[key];
        const rightValue = left[key];
        const matchingObjectType = typeof leftValue === 'object' && typeof rightValue === 'object';
        const isOneArray = Array.isArray(leftValue) || Array.isArray(rightValue);
        if (matchingObjectType && (left[key] || right[key]) && !isOneArray) {
            mergeLeft(left[key], right[key]);
        }
        else {
            left[key] = right[key];
        }
    });
    return left;
}
exports.mergeLeft = mergeLeft;
function convertMicrosecondsToMS(ms) {
    ms = typeof ms === 'string' ? parseInt(ms, 10) : ms;
    return Math.floor(ms * 100) / 100000;
}
exports.convertMicrosecondsToMS = convertMicrosecondsToMS;
function convertMSToMicroseconds(ms) {
    ms = typeof ms === 'string' ? parseInt(ms, 10) : ms;
    return Math.floor(ms * 1000);
}
exports.convertMSToMicroseconds = convertMSToMicroseconds;
function getCookiesFromHAR(har) {
    let cookies = [];
    har.log.entries.forEach((entry) => {
        if (entry.response.cookies.length > 0) {
            cookies.push(entry.response.cookies);
        }
    });
    return (cookies = [].concat.apply([], cookies));
}
exports.getCookiesFromHAR = getCookiesFromHAR;
function normalizeFnName(name) {
    if (name === '') {
        name = '(anonymous)';
    }
    return name;
}
exports.normalizeFnName = normalizeFnName;
function setTraceEvents(file) {
    if (!Array.isArray(file)) {
        file = file.traceEvents;
    }
    return file;
}
exports.setTraceEvents = setTraceEvents;
function collect(val, memo) {
    memo.push(val);
    return memo;
}
exports.collect = collect;
function format(ts, start) {
    let ms = ((ts - start) / 1000).toFixed(2).toString();
    while (ms.length < 10) {
        ms = ' ' + ms;
    }
    return `${ms} ms`;
}
exports.format = format;
function isMark(event) {
    return event.ph === 'R';
}
exports.isMark = isMark;
function isFrameMark(frame, event) {
    return event.ph === 'R' && event.args.frame === frame;
}
exports.isFrameMark = isFrameMark;
function isFrameNavigationStart(frame, event) {
    return isFrameMark(frame, event) && event.name === 'navigationStart';
}
exports.isFrameNavigationStart = isFrameNavigationStart;
function isUserMark(event) {
    return (event.ph === 'R' &&
        event.cat === 'blink.user_timing' &&
        Object.keys(event.args).length === 0);
}
exports.isUserMark = isUserMark;
function isCommitLoad(event) {
    return (event.ph === 'X' &&
        event.name === 'CommitLoad' &&
        event.args.data !== undefined &&
        event.args.data.isMainFrame);
}
exports.isCommitLoad = isCommitLoad;
function byTime(a, b) {
    return a.ts - b.ts;
}
exports.byTime = byTime;
function findFrame(events, url) {
    const event = events
        .filter(isCommitLoad)
        .find((e) => e.args.data.url.startsWith(url));
    if (event) {
        return event.args.data.frame;
    }
    return null;
}
exports.findFrame = findFrame;
function parseMarkers(m) {
    const a = [];
    if (typeof m === 'string') {
        m = m.split(',');
    }
    m.forEach(marker => {
        a.push({
            label: marker,
            start: marker,
        });
    });
    return a;
}
exports.parseMarkers = parseMarkers;
function removeDuplicates(collection) {
    return [...new Set(collection)];
}
exports.removeDuplicates = removeDuplicates;
function fillArray(arrLngth, incr = 1, strt = 0) {
    const a = [];
    while (a.length < arrLngth) {
        if (a.length < 1) {
            a.push(strt);
        }
        a.push(strt + incr);
        strt = strt + incr;
    }
    return a;
}
exports.fillArray = fillArray;
/**
 * "name" is expected to be a titlecased string. We want something the user can type easily so the passed string
 * is converted into lowercased words dasherized. Any extra "/" will also be removed.
 *
 * @param str - String to be converted to dasherized case
 */
function convertToTypable(name) {
    const split = name.split(' ');
    const lowercasedWords = split.map(word => word.toLowerCase().replace(/\//g, ''));
    return lowercasedWords.join('-');
}
exports.convertToTypable = convertToTypable;
function toNearestHundreth(n) {
    return Math.round(n * 100) / 100;
}
exports.toNearestHundreth = toNearestHundreth;
exports.chalkScheme = {
    white: chalk_1.default.rgb(255, 255, 255),
    warning: chalk_1.default.rgb(255, 174, 66),
    header: chalk_1.default.rgb(255, 255, 255),
    regress: chalk_1.default.rgb(239, 100, 107),
    neutral: chalk_1.default.rgb(225, 225, 225),
    significant: chalk_1.default.rgb(0, 191, 255),
    imprv: chalk_1.default.rgb(135, 197, 113),
    phase: chalk_1.default.rgb(225, 225, 225),
    faint: chalk_1.default.rgb(80, 80, 80),
    checkmark: chalk_1.default.rgb(133, 153, 36)(`${logSymbols.success}`),
    blackBgGreen: chalk_1.default.green.bgGreen,
    blackBgRed: chalk_1.default.rgb(239, 100, 107).bgRed,
    blackBgBlue: chalk_1.default.rgb(24, 132, 228).bgRgb(24, 132, 228),
    blackBgYellow: chalk_1.default.rgb(255, 174, 66).bgRgb(255, 174, 66),
    tbBranding: {
        lime: chalk_1.default.rgb(199, 241, 106),
        blue: chalk_1.default.rgb(24, 132, 228),
        aqua: chalk_1.default.rgb(56, 210, 211),
        dkBlue: chalk_1.default.rgb(10, 45, 70),
        grey: chalk_1.default.rgb(153, 153, 153),
    },
};
//# sourceMappingURL=utils.js.map