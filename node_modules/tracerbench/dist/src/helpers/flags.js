"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-console*/
const command_1 = require("@oclif/command");
const core_1 = require("@tracerbench/core");
const default_flag_args_1 = require("../command-config/default-flag-args");
const utils_1 = require("./utils");
const simulate_device_options_1 = require("./simulate-device-options");
/*
! oclif flags.build#parse will only execute when the flag:string is passed directly
! from the cli. thus when passed via the tbconfig.json or the defaultFlagArgs
! the parse method will never execute
! todo: mitigate above by either extending the flags oclif command calling parse
! and type checking in all circumstances
*/
exports.runtimeStats = command_1.flags.boolean({
    description: `Compare command output deep-dive stats during run.`,
    default: false,
});
exports.servers = command_1.flags.build({
    description: `Optional servers config for A/B testing with har-remix dist slicing with socks proxy. All paths within this config are relative.`,
});
exports.plotTitle = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('plotTitle'),
    description: `Specify the title of the report pdf file.`,
});
exports.config = command_1.flags.build({
    description: `Specify an alternative directory rather than the project root for the tbconfig.json. This explicit config will overwrite all.`,
});
exports.report = command_1.flags.boolean({
    description: `Generate a PDF report directly after running the compare command.`,
    default: false,
});
exports.headless = command_1.flags.boolean({
    description: `Run with headless chrome flags`,
    default: false,
});
exports.insights = command_1.flags.boolean({
    description: `Analyze insights from command.`,
    default: false,
});
exports.debug = command_1.flags.boolean({
    description: `Debug flag per command. Will output noisy command`,
    default: false,
});
exports.regressionThreshold = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('regressionThreshold'),
    description: `The upper limit the experiment can regress slower in milliseconds. eg 100`,
    parse: (ms) => {
        return parseInt(ms, 10);
    },
});
exports.iterations = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('iterations'),
    description: `Number of runs`,
    parse: iterations => {
        parseInt(iterations, 10);
    },
});
exports.browserArgs = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('browserArgs'),
    description: `(Default Recommended) Additional chrome flags for the TracerBench render benchmark. TracerBench includes many non-configurable defaults in this category.`,
    parse: (s) => {
        return s.split(',');
    },
});
exports.tracingLocationSearch = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('tracingLocationSearch'),
    description: `The document location search param.`,
});
exports.appName = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('appName'),
    description: 'The name of your application',
});
exports.event = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('event'),
    description: 'Slice time and see the events before and after the time slice',
});
exports.methods = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('methods'),
    description: 'List of methods to aggregate',
});
exports.cpuThrottleRate = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('cpuThrottleRate'),
    description: 'CPU throttle multiplier',
    parse: (cpuThrottleRate) => {
        return parseInt(cpuThrottleRate, 10);
    },
});
exports.fidelity = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('fidelity'),
    description: `Directly correlates to the number of samples per trace. High is the longest trace time.`,
    parse: (fidelity) => {
        const warnMessage = `Expected --fidelity=${fidelity} to be either a number or one of: ${Object.keys(default_flag_args_1.fidelityLookup)}. Defaulting to ${default_flag_args_1.getDefaultValue('fidelity')}`;
        if (typeof fidelity === 'string') {
            // integers are coming as string from oclif
            if (Number.isInteger(parseInt(fidelity, 10))) {
                return parseInt(fidelity, 10);
            }
            // is a string and is either test/low/med/high
            if (Object.keys(default_flag_args_1.fidelityLookup).includes(fidelity)) {
                return parseInt(default_flag_args_1.fidelityLookup[fidelity], 10);
            }
            else {
                console.warn(`${warnMessage}`);
            }
        }
        return fidelity === 'number' ? fidelity : default_flag_args_1.getDefaultValue('fidelity');
    },
});
exports.markers = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('markers'),
    description: 'User Timing Markers',
    parse: utils_1.parseMarkers,
});
exports.network = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('network'),
    description: 'Simulated network conditions.',
    options: ['none', 'offline', 'dialup', 'slow-2g', '2g', 'slow-edge', 'edge', 'slow-3g', 'dsl', '3g', 'fast-3g', '4g', 'cable', 'LTE', 'FIOS'],
    parse: (n) => {
        return core_1.networkConditions[n];
    },
});
exports.tbResultsFolder = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('tbResultsFolder'),
    description: 'The output folder path for all tracerbench results',
});
exports.url = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('url'),
    description: 'URL to visit for record-har, timings & trace commands',
});
exports.controlURL = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('controlURL'),
    description: 'Control URL to visit for compare command',
});
exports.experimentURL = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('experimentURL'),
    description: 'Experiment URL to visit for compare command',
});
exports.locations = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('locations'),
    description: 'include locations in names',
});
exports.filter = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('filter'),
    description: 'User timing marks start with',
});
exports.traceFrame = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('traceFrame'),
    description: 'Specify a trace insights frame',
});
exports.socksPorts = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('socksPorts'),
    description: 'Specify a socks proxy port as browser option for control and experiment',
    parse: (s) => {
        if (typeof s === 'string') {
            const a = s.split(',');
            if (a.length > 2) {
                console.error(`Maximium of two socks ports can be passed`);
            }
            return [parseInt(a[0], 10), parseInt(a[1], 10)];
        }
    },
});
exports.emulateDevice = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('emulateDevice'),
    description: `Emulate a mobile device screen size.`,
    options: simulate_device_options_1.default.map((setting) => `${setting.typeable}`),
});
exports.emulateDeviceOrientation = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('emulateDeviceOrientation'),
    description: `Expected to be either "vertical" or "horizontal". Dictates orientation of device screen.`,
    options: ['horizontal', 'vertical'],
});
exports.cookiespath = command_1.flags.build({
    description: `The path to a JSON file containing cookies to authenticate against the correlated URL`,
});
exports.tbconfigpath = command_1.flags.build({
    description: `The path to a TracerBench configuration file (tbconfig.json)`,
});
exports.harpath = command_1.flags.build({
    description: `The path to the HTTP Archive File (HAR)`,
});
exports.tracepath = command_1.flags.build({
    description: `The path to the generated trace.json file`,
});
exports.dest = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue('dest'),
    description: `The destination path for the generated file`,
});
exports.filename = command_1.flags.build({
    description: `The filename for the generated file`,
});
exports.marker = command_1.flags.build({
    description: `The last marker before ending recording`,
    default: 'domComplete',
});
//# sourceMappingURL=flags.js.map