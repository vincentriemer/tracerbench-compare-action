"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Handlebars = require("handlebars");
const path = require("path");
const utils_1 = require("./utils");
const stats_1 = require("./statistics/stats");
const fs_extra_1 = require("fs-extra");
const default_flag_args_1 = require("../command-config/default-flag-args");
exports.PAGE_LOAD_TIME = 'duration';
const CHART_CSS_PATH = path.join(__dirname, '../static/chart-bootstrap.css');
const CHART_JS_PATH = path.join(__dirname, '../static/chartjs-2.8.0-chart.min.js');
const REPORT_PATH = path.join(__dirname, '../static/report-template.hbs');
const PHASE_DETAIL_PARTIAL = path.join(__dirname, '../static/phase-detail-partial.hbs');
const PHASE_CHART_JS_PARTIAL = path.join(__dirname, '../static/phase-chart-js-partial.hbs');
const CHART_CSS = fs_extra_1.readFileSync(CHART_CSS_PATH, 'utf8');
const CHART_JS = fs_extra_1.readFileSync(CHART_JS_PATH, 'utf8');
const PHASE_DETAIL_TEMPLATE_RAW = fs_extra_1.readFileSync(PHASE_DETAIL_PARTIAL, 'utf8');
const PHASE_CHART_JS_TEMPLATE_RAW = fs_extra_1.readFileSync(PHASE_CHART_JS_PARTIAL, 'utf8');
let REPORT_TEMPLATE_RAW = fs_extra_1.readFileSync(REPORT_PATH, 'utf8');
REPORT_TEMPLATE_RAW = REPORT_TEMPLATE_RAW.toString()
    .replace('{{!-- TRACERBENCH-CHART-BOOTSTRAP.CSS --}}', `<style>${CHART_CSS}</style>`)
    .replace('{{!-- TRACERBENCH-CHART-JS --}}', `<script>${CHART_JS}</script>`);
Handlebars.registerPartial('phaseChartJSSection', PHASE_CHART_JS_TEMPLATE_RAW);
Handlebars.registerPartial('phaseDetailSection', PHASE_DETAIL_TEMPLATE_RAW);
/**
 * Camel case helper
 */
Handlebars.registerHelper('toCamel', val => {
    return val.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
});
/**
 * Negative means slower
 */
Handlebars.registerHelper('isFaster', analysis => {
    return analysis.hlDiff > 0;
});
/**
 * Absolute number helper
 */
Handlebars.registerHelper('abs', num => {
    return Math.abs(num);
});
/**
 * Sort the given numbers by their absolute values
 */
Handlebars.registerHelper('absSort', (num1, num2, position) => {
    const sorted = [Math.abs(num1), Math.abs(num2)];
    sorted.sort((a, b) => a - b);
    return sorted[position];
});
/**
 * Extract the phases and page load time latency into sorted buckets by phase
 *
 * @param samples - Array of "sample" objects
 * @param valueGen - Calls this function to extract the value from the phase. A
 *   "phase" is passed containing duration and start
 */
function bucketPhaseValues(samples, valueGen = (a) => a.duration) {
    const buckets = { [exports.PAGE_LOAD_TIME]: [] };
    samples.forEach((sample) => {
        buckets[exports.PAGE_LOAD_TIME].push(sample[exports.PAGE_LOAD_TIME]);
        sample.phases.forEach(phaseData => {
            const bucket = buckets[phaseData.phase] || [];
            bucket.push(valueGen(phaseData));
            buckets[phaseData.phase] = bucket;
        });
    });
    Object.keys(buckets).forEach(phase => {
        buckets[phase].sort();
    });
    return buckets;
}
exports.bucketPhaseValues = bucketPhaseValues;
/**
 * Override the default server and plot title attributes
 *
 * @param tbConfig - Concerned only about the "servers" and "plotTitle"
 *   attribute
 * @param version - Browser version
 */
function resolveTitles(tbConfig, version) {
    const reportTitles = {
        servers: [{ name: 'Control' }, { name: 'Experiment' }],
        plotTitle: default_flag_args_1.defaultFlagArgs.plotTitle,
        browserVersion: version
    };
    if (tbConfig.servers) {
        reportTitles.servers = tbConfig.servers.map((titleConfig, idx) => {
            if (idx === 0) {
                return { name: `Control: ${titleConfig.name}` };
            }
            else {
                return { name: `Experiment: ${titleConfig.name}` };
            }
        });
    }
    if (tbConfig.plotTitle) {
        reportTitles.plotTitle = tbConfig.plotTitle;
    }
    return reportTitles;
}
exports.resolveTitles = resolveTitles;
/**
 * Generate the HTML render data for the cumulative chart. Ensure to convert to
 * milliseconds for presentation
 *
 * @param controlData - Samples of the benchmark of control server
 * @param experimentData - Samples of the benchmark experiment server
 */
function buildCumulativeChartData(controlData, experimentData) {
    const cumulativeValueFunc = (a) => utils_1.convertMicrosecondsToMS(a.start + a.duration);
    const valuesByPhaseControl = bucketPhaseValues(controlData.samples, cumulativeValueFunc);
    const valuesByPhaseExperiment = bucketPhaseValues(experimentData.samples, cumulativeValueFunc);
    const phases = Object.keys(valuesByPhaseControl).filter(k => k !== exports.PAGE_LOAD_TIME);
    return {
        categories: JSON.stringify(phases),
        controlData: JSON.stringify(phases.map(k => valuesByPhaseControl[k])),
        experimentData: JSON.stringify(phases.map(k => valuesByPhaseExperiment[k]))
    };
}
exports.buildCumulativeChartData = buildCumulativeChartData;
/**
 * Call the stats helper functions to generate the confidence interval and
 * Hodgesâ€“Lehmann estimator. Format the data into HTMLSectionRenderData
 * structure.
 *
 * @param controlValues - Values for the control for the phase
 * @param experimentValues - Values for the experiment for the phase
 * @param phaseName - Name of the phase the values represent
 */
function formatPhaseData(controlValues, experimentValues, phaseName) {
    const stats = new stats_1.Stats({
        control: controlValues,
        experiment: experimentValues,
        name: 'output'
    });
    const isNotSignificant = (stats.confidenceInterval.min < 0 && 0 < stats.confidenceInterval.max) ||
        (stats.confidenceInterval.min > 0 && 0 > stats.confidenceInterval.max) ||
        (stats.confidenceInterval.min === 0 && stats.confidenceInterval.max === 0);
    return {
        phase: phaseName,
        identifierHash: phaseName,
        isSignificant: !isNotSignificant,
        // Ensure to convert to milliseconds for presentation
        controlSamples: JSON.stringify(controlValues.map(val => utils_1.convertMicrosecondsToMS(val))),
        experimentSamples: JSON.stringify(experimentValues.map(val => utils_1.convertMicrosecondsToMS(val))),
        sampleCount: controlValues.length,
        ciMin: stats.confidenceInterval.min,
        ciMax: stats.confidenceInterval.max,
        hlDiff: stats.estimator,
        servers: undefined
    };
}
exports.formatPhaseData = formatPhaseData;
/**
 * Prioritize the phase that has the largest difference in regression first.
 */
function phaseSorter(a, b) {
    const A_ON_TOP = -1;
    const B_ON_TOP = 1;
    if (a.isSignificant) {
        if (!b.isSignificant) {
            return A_ON_TOP;
        }
        else {
            // If both are significant prefer slowest one
            return a.hlDiff - b.hlDiff;
        }
    }
    if (b.isSignificant) {
        if (!a.isSignificant) {
            return B_ON_TOP;
        }
    }
    return 0;
}
exports.phaseSorter = phaseSorter;
function generateDataForHTML(controlData, experimentData, reportTitles) {
    const valuesByPhaseControl = bucketPhaseValues(controlData.samples);
    const valuesByPhaseExperiment = bucketPhaseValues(experimentData.samples);
    const subPhases = Object.keys(valuesByPhaseControl)
        .filter(k => k !== exports.PAGE_LOAD_TIME);
    const durationSection = formatPhaseData(valuesByPhaseControl[exports.PAGE_LOAD_TIME], valuesByPhaseExperiment[exports.PAGE_LOAD_TIME], exports.PAGE_LOAD_TIME);
    const subPhaseSections = subPhases.map(phase => {
        const controlValues = valuesByPhaseControl[phase];
        const experimentValues = valuesByPhaseExperiment[phase];
        const renderDataForPhase = formatPhaseData(controlValues, experimentValues, phase);
        renderDataForPhase.servers = reportTitles.servers;
        return renderDataForPhase;
    });
    durationSection.servers = reportTitles.servers;
    subPhaseSections.sort(phaseSorter);
    return { durationSection, subPhaseSections };
}
exports.generateDataForHTML = generateDataForHTML;
function createConsumeableHTML(controlData, experimentData, tbConfig) {
    const reportTitles = resolveTitles(tbConfig, controlData.meta.browserVersion);
    const { durationSection, subPhaseSections } = generateDataForHTML(controlData, experimentData, reportTitles);
    const template = Handlebars.compile(REPORT_TEMPLATE_RAW);
    return template({
        cumulativeChartData: buildCumulativeChartData(controlData, experimentData),
        durationSection,
        reportTitles,
        subPhaseSections,
        configsSJSONString: JSON.stringify(tbConfig, null, 4),
        sectionFormattedDataJson: JSON.stringify(subPhaseSections)
    });
}
exports.default = createConsumeableHTML;
//# sourceMappingURL=create-consumable-html.js.map