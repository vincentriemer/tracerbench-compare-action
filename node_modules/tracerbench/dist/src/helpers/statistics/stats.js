"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3_array_1 = require("d3-array");
const d3_scale_1 = require("d3-scale");
const confidence_interval_1 = require("./confidence-interval");
const utils_1 = require("../utils");
// ! all stats assume microseconds from tracerbench and round to milliseconds
class Stats {
    constructor(options) {
        const { name } = options;
        let { control, experiment } = options;
        control = control.sort((a, b) => a - b);
        experiment = experiment.sort((a, b) => a - b);
        control = control.map(x => utils_1.convertMicrosecondsToMS(x));
        experiment = experiment.map(x => utils_1.convertMicrosecondsToMS(x));
        this.name = name;
        this.sampleCount = {
            control: control.length,
            experiment: experiment.length,
        };
        this.range = this.getRange(control, experiment);
        this.sparkLine = {
            control: this.getSparkline(this.getHistogram(this.range, control)),
            experiment: this.getSparkline(this.getHistogram(this.range, experiment)),
        };
        this.confidenceInterval = this.getConfidenceInterval(control, experiment);
        this.estimator = Math.round(this.getHodgesLehmann(control, experiment));
        this.sevenFigureSummary = {
            control: this.getSevenFigureSummary(control),
            experiment: this.getSevenFigureSummary(experiment),
        };
    }
    getSevenFigureSummary(a) {
        return {
            min: Math.round(Math.min.apply(null, a)),
            max: Math.round(Math.max.apply(null, a)),
            10: Math.round(d3_array_1.quantile(a, 0.1)),
            25: Math.round(d3_array_1.quantile(a, 0.25)),
            50: Math.round(d3_array_1.quantile(a, 0.5)),
            75: Math.round(d3_array_1.quantile(a, 0.75)),
            90: Math.round(d3_array_1.quantile(a, 0.9)),
        };
    }
    getConfidenceInterval(control, experiment) {
        const sigVal = 0.05;
        const interval = 1 - sigVal;
        const ci = confidence_interval_1.confidenceInterval(control, experiment, interval);
        const isSig = (ci[0] < 0 && 0 < ci[1]) ||
            (ci[0] > 0 && 0 > ci[1]) ||
            (ci[0] === 0 && ci[1] === 0)
            ? false
            : true;
        return {
            min: Math.round(Math.ceil(ci[0] * 100) / 100),
            max: Math.round(Math.ceil(ci[1] * 100) / 100),
            isSig,
        };
    }
    getHodgesLehmann(control, experiment) {
        let crossProduct = d3_array_1.cross(control, experiment, (a, b) => a - b);
        crossProduct = crossProduct.sort((a, b) => a - b);
        return d3_array_1.quantile(crossProduct, 0.5);
    }
    getRange(control, experiment) {
        const a = control.concat(experiment);
        return { min: Math.min(...a), max: Math.max(...a) };
    }
    getHistogram(range, a) {
        const x = d3_scale_1.scaleLinear()
            .domain([range.min, range.max])
            .range([range.min, range.max]);
        const h = d3_array_1.histogram()
            .value(d => {
            return d;
        })
            .domain(x.domain())
            .thresholds(x.ticks());
        return h(a).map(i => {
            return i.length;
        });
    }
    getSparkline(numbers, min = Math.min.apply(null, numbers), max = Math.max.apply(null, numbers)) {
        function lshift(n, bits) {
            return Math.floor(n) * Math.pow(2, bits);
        }
        const ticks = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];
        const results = [];
        let f = Math.floor(lshift(max - min, 8) / (ticks.length - 1));
        if (f < 1) {
            f = 1;
        }
        numbers.forEach((n) => {
            const value = ticks[Math.floor(lshift(n - min, 8) / f)];
            results.push(value);
        });
        return `${results.join('')}`;
    }
}
exports.Stats = Stats;
//# sourceMappingURL=stats.js.map