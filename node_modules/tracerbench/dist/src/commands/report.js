"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path_1 = require("path");
const command_config_1 = require("../command-config");
const create_consumable_html_1 = require("../helpers/create-consumable-html");
const flags_1 = require("../helpers/flags");
const print_to_pdf_1 = require("../helpers/print-to-pdf");
const utils_1 = require("../helpers/utils");
const ARTIFACT_FILE_NAME = 'artifact';
class Report extends command_config_1.TBBaseCommand {
    constructor(argv, config) {
        super(argv, config);
        const { flags } = this.parse(Report);
        this.reportFlags = flags;
    }
    // instantiated before this.run()
    async init() {
        const { flags } = this.parse(Report);
        this.parsedConfig = command_config_1.getConfig(flags.config, flags, this.explicitFlags);
        this.reportFlags = flags;
        await this.parseFlags();
    }
    /**
     * Ensure the input file is valid and call the helper function "createConsumeableHTML"
     * to generate the HTML string for the output file.
     */
    async run() {
        const tbResultsFolder = this.reportFlags.tbResultsFolder;
        const inputFilePath = path_1.join(tbResultsFolder, 'compare.json');
        let absPathToHTML;
        let absOutputPath;
        let renderedHTML;
        let htmlOutputPath;
        let outputFileName;
        let inputData = [];
        // If the input file cannot be found, exit with an error
        if (!fs.existsSync(inputFilePath)) {
            this.error(`Input json file does not exist. Please make sure ${inputFilePath} exists`, { exit: 1 });
        }
        try {
            inputData = JSON.parse(fs.readFileSync(inputFilePath, 'utf8'));
        }
        catch (error) {
            this.error(`Had issues parsing the input JSON file. Please make sure ${inputFilePath} is a valid JSON`, { exit: 1 });
        }
        const controlData = inputData.find(element => {
            return element.set === 'control';
        });
        const experimentData = inputData.find(element => {
            return element.set === 'experiment';
        });
        if (!controlData || !experimentData) {
            this.error(`Missing control or experiment set in JSON`, { exit: 1 });
        }
        outputFileName = this.determineOutputFileName(tbResultsFolder);
        renderedHTML = create_consumable_html_1.default(controlData, experimentData, this.parsedConfig);
        if (!fs.existsSync(tbResultsFolder)) {
            fs.mkdirSync(tbResultsFolder, { recursive: true });
        }
        htmlOutputPath = path_1.join(tbResultsFolder, `/${outputFileName}.html`);
        absPathToHTML = path_1.resolve(htmlOutputPath);
        fs.writeFileSync(absPathToHTML, renderedHTML);
        absOutputPath = path_1.resolve(path_1.join(tbResultsFolder + `/${outputFileName}.pdf`));
        await print_to_pdf_1.default(`file://${absPathToHTML}`, absOutputPath);
        this.log(`\n${utils_1.chalkScheme.blackBgBlue(`    ${utils_1.chalkScheme.white('Benchmark Reports')}    `)}`);
        this.log(`\nJSON: ${utils_1.chalkScheme.tbBranding.blue.underline.bold(`${this.parsedConfig.tbResultsFolder}/compare.json`)}`);
        this.log(`\nPDF: ${utils_1.chalkScheme.tbBranding.blue.underline.bold(absOutputPath)}`);
        this.log(`\nHTML: ${utils_1.chalkScheme.tbBranding.blue.underline.bold(absPathToHTML)}\n`);
    }
    async parseFlags() {
        const { tbResultsFolder } = this.parsedConfig;
        // if the folder for the tracerbench results file
        // does not exist then create it
        if (!fs.existsSync(tbResultsFolder)) {
            fs.mkdirSync(tbResultsFolder);
        }
    }
    determineOutputFileName(outputFolder) {
        let count = 1;
        while (true) {
            const candidateHTML = path_1.join(outputFolder, `${ARTIFACT_FILE_NAME}-${count}.html`);
            const candidatePDF = path_1.join(outputFolder, `${ARTIFACT_FILE_NAME}-${count}.pdf`);
            if (!fs.existsSync(candidateHTML) && !fs.existsSync(candidatePDF)) {
                break;
            }
            count += 1;
        }
        return `artifact-${count}`;
    }
}
exports.default = Report;
Report.description = `Parses the output json from tracerbench and formats it into pdf and html`;
Report.flags = {
    tbResultsFolder: flags_1.tbResultsFolder({ required: true }),
    config: flags_1.config(),
};
//# sourceMappingURL=report.js.map