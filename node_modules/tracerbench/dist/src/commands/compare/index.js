"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const command_config_1 = require("../../command-config");
const core_1 = require("@tracerbench/core");
const flags_1 = require("../../helpers/flags");
const default_flag_args_1 = require("../../command-config/default-flag-args");
const utils_1 = require("../../helpers/utils");
const simulate_device_options_1 = require("../../helpers/simulate-device-options");
const tb_config_1 = require("../../command-config/tb-config");
const analyze_1 = require("./analyze");
const report_1 = require("../report");
class Compare extends command_config_1.TBBaseCommand {
    constructor(argv, config) {
        super(argv, config);
        this.parsedConfig = default_flag_args_1.defaultFlagArgs;
        this.analyzedJSONString = '';
        const { flags } = this.parse(Compare);
        this.explicitFlags = argv;
        this.compareFlags = flags;
    }
    // instantiated before this.run()
    async init() {
        const { flags } = this.parse(Compare);
        this.parsedConfig = command_config_1.getConfig(flags.config, flags, this.explicitFlags);
        this.compareFlags = flags;
        await this.parseFlags();
    }
    async run() {
        const { hideAnalysis } = this.compareFlags;
        const [controlSettings, experimentSettings,] = this.generateControlExperimentServerConfig();
        // this should be directly above the instantiation of the InitialRenderBenchmarks
        if (this.parsedConfig.debug) {
            Object.entries(this.parsedConfig).forEach(([key, value]) => {
                if (value) {
                    this.log(`${key}: ${JSON.stringify(value)}`);
                }
            });
        }
        const benchmarks = {
            control: new core_1.InitialRenderBenchmark(controlSettings),
            experiment: new core_1.InitialRenderBenchmark(experimentSettings),
        };
        const runner = new core_1.Runner([benchmarks.control, benchmarks.experiment]);
        await runner
            .run(this.compareFlags.fidelity, this.log)
            .then(async (results) => {
            if (!results[0].samples[0]) {
                this.error(`Could not sample from provided urls\nCONTROL: ${this.parsedConfig.controlURL}\nEXPERIMENT: ${this.parsedConfig.experimentURL}.`);
            }
            const resultJSONPath = `${this.parsedConfig.tbResultsFolder}/compare.json`;
            fs.writeFileSync(resultJSONPath, JSON.stringify(results, null, 2));
            // tslint:disable-next-line: max-line-length
            const message = `${utils_1.chalkScheme.blackBgGreen(`    ${utils_1.chalkScheme.white('SUCCESS!')}    `)} ${this.parsedConfig.fidelity} test samples were taken.`;
            this.log(`\n${message}`);
            if (!hideAnalysis) {
                this.analyzedJSONString = await analyze_1.default.run([
                    resultJSONPath,
                    '--fidelity',
                    `${this.parsedConfig.fidelity}`,
                    '--tbResultsFolder',
                    `${this.parsedConfig.tbResultsFolder}`,
                    '--regressionThreshold',
                    `${this.parsedConfig.regressionThreshold}`,
                ]);
                fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/report.json`, this.analyzedJSONString);
            }
            // if we want to run the Report without calling a separate command
            if (this.parsedConfig.report) {
                await report_1.default.run([
                    '--tbResultsFolder',
                    `${this.parsedConfig.tbResultsFolder}`,
                    '--config',
                    `${this.parsedConfig.config}`,
                ]);
            }
            // with debug flag output three files
            // on config specifics
            if (this.parsedConfig.debug) {
                fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/server-control-settings.json`, JSON.stringify(Object.assign(controlSettings), null, 2));
                fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/server-experiment-settings.json`, JSON.stringify(Object.assign(experimentSettings), null, 2));
                fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/compare-flags-settings.json`, JSON.stringify(Object.assign(this.parsedConfig), null, 2));
            }
        })
            .catch((err) => {
            this.error(err);
        });
        return this.analyzedJSONString;
    }
    async parseFlags() {
        const { tbResultsFolder, fidelity, markers, regressionThreshold, headless, controlURL, experimentURL, } = this.parsedConfig;
        // modifies properties of flags that were not set
        // during flag.parse(). these are intentionally
        // not deconstructed as to maintain the mutable
        // flags object state
        if (typeof fidelity === 'string') {
            this.compareFlags.fidelity = parseInt(default_flag_args_1.fidelityLookup[fidelity], 10);
        }
        if (typeof markers === 'string') {
            this.parsedConfig.markers = utils_1.parseMarkers(markers);
        }
        if (typeof regressionThreshold === 'string') {
            this.parsedConfig.regressionThreshold = parseInt(regressionThreshold, 10);
        }
        if (typeof controlURL === undefined) {
            this.error('controlURL is required either in the tbconfig.json or as cli flag');
        }
        if (typeof experimentURL === undefined) {
            this.error('experimentURL is required either in the tbconfig.json or as cli flag');
        }
        // if headless flag is true include the headless flags
        if (headless) {
            this.parsedConfig.browserArgs = this.compareFlags.browserArgs.concat(default_flag_args_1.headlessFlags);
        }
        // if the folder for the tracerbench results file
        // does not exist then create it
        fs.mkdirpSync(path.join(tbResultsFolder, 'traces'));
    }
    /**
     * Final result of the configs are in the following order:
     *
     * controlConfigs = tbconfig:controlBenchmarkEnvironment > command line > tbconfig > default
     * experimentConfigs = tbconfig:experimentBenchmarkEnvironment > command line > tbconfig > default
     *
     * This functions handles the tsconfig:** part since it is assumed that parent function that passed input "flags"
     * would've handled "command line > tbconfig > default"
     *
     * @param this.parsedConfig - Object containing configs parsed from the Command class
     */
    generateControlExperimentServerConfig() {
        // delay in ms times the number of samples. this improves variance.
        // eg 100 total samples X 200ms per sample = 20 seconds total added to the trace time
        const delay = 200;
        const controlBrowser = {
            additionalArguments: this.compareFlags.browserArgs,
        };
        const experimentBrowser = {
            additionalArguments: this.compareFlags.browserArgs,
        };
        let controlNetwork;
        let experimentNetwork;
        let experimentEmulateDevice;
        let experimentEmulateDeviceOrientation;
        let controlEmulateDevice;
        let controlEmulateDeviceOrientation;
        let controlSettings;
        let experimentSettings;
        // config for the browsers to leverage socks proxy
        if (this.parsedConfig.socksPorts) {
            controlBrowser.additionalArguments = controlBrowser.additionalArguments.concat([`--proxy-server=socks5://0.0.0.0:${this.parsedConfig.socksPorts[0]}`]);
            experimentBrowser.additionalArguments = experimentBrowser.additionalArguments.concat([`--proxy-server=socks5://0.0.0.0:${this.parsedConfig.socksPorts[1]}`]);
        }
        controlNetwork = utils_1.checkEnvironmentSpecificOverride('network', this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        controlEmulateDevice = utils_1.checkEnvironmentSpecificOverride('emulateDevice', this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        controlEmulateDeviceOrientation = utils_1.checkEnvironmentSpecificOverride('emulateDeviceOrientation', this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        experimentNetwork = utils_1.checkEnvironmentSpecificOverride('network', this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        experimentEmulateDevice = utils_1.checkEnvironmentSpecificOverride('emulateDevice', this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        experimentEmulateDeviceOrientation = utils_1.checkEnvironmentSpecificOverride('emulateDeviceOrientation', this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        controlSettings = {
            browser: controlBrowser,
            cpuThrottleRate: utils_1.checkEnvironmentSpecificOverride('cpuThrottleRate', this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig),
            delay,
            emulateDeviceSettings: controlEmulateDevice
                ? simulate_device_options_1.getEmulateDeviceSettingForKeyAndOrientation(controlEmulateDevice, controlEmulateDeviceOrientation)
                : undefined,
            markers: this.compareFlags.markers,
            networkConditions: controlNetwork
                ? core_1.networkConditions[controlNetwork]
                : this.compareFlags.network,
            name: 'control',
            runtimeStats: this.compareFlags.runtimeStats,
            saveTraces: i => `${this.compareFlags.tbResultsFolder}/traces/control${i}.json`,
            url: path.join(this.compareFlags.controlURL + this.compareFlags.tracingLocationSearch),
        };
        experimentSettings = {
            browser: experimentBrowser,
            cpuThrottleRate: utils_1.checkEnvironmentSpecificOverride('cpuThrottleRate', this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig),
            delay,
            emulateDeviceSettings: experimentEmulateDevice
                ? simulate_device_options_1.getEmulateDeviceSettingForKeyAndOrientation(experimentEmulateDevice, experimentEmulateDeviceOrientation)
                : undefined,
            markers: this.compareFlags.markers,
            networkConditions: experimentNetwork
                ? core_1.networkConditions[experimentNetwork]
                : this.compareFlags.network,
            name: 'experiment',
            runtimeStats: this.compareFlags.runtimeStats,
            saveTraces: i => `${this.compareFlags.tbResultsFolder}/traces/experiment${i}.json`,
            url: path.join(this.compareFlags.experimentURL +
                this.compareFlags.tracingLocationSearch),
        };
        return [controlSettings, experimentSettings];
    }
}
exports.default = Compare;
Compare.description = 'Compare the performance delta between an experiment and control';
Compare.flags = {
    hideAnalysis: command_config_1.flags.boolean({
        default: false,
        description: 'Hide the the analysis output in terminal',
    }),
    browserArgs: flags_1.browserArgs({ required: true }),
    cpuThrottleRate: flags_1.cpuThrottleRate({ required: true }),
    fidelity: flags_1.fidelity({ required: true }),
    markers: flags_1.markers({ required: true }),
    network: flags_1.network({ required: true }),
    tbResultsFolder: flags_1.tbResultsFolder({ required: true }),
    controlURL: flags_1.controlURL({ required: false }),
    experimentURL: flags_1.experimentURL({ required: false }),
    tracingLocationSearch: flags_1.tracingLocationSearch({ required: true }),
    emulateDevice: flags_1.emulateDevice(),
    emulateDeviceOrientation: flags_1.emulateDeviceOrientation(),
    socksPorts: flags_1.socksPorts(),
    regressionThreshold: flags_1.regressionThreshold(),
    config: flags_1.config(),
    runtimeStats: flags_1.runtimeStats,
    report: flags_1.report,
    debug: flags_1.debug,
    headless: flags_1.headless,
};
//# sourceMappingURL=index.js.map