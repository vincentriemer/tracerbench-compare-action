"use strict";
/* tslint:disable:no-console*/
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const tb_config_1 = require("./tb-config");
const JSON5 = require("json5");
const default_flag_args_1 = require("./default-flag-args");
const utils_1 = require("../helpers/utils");
const configFileKeys = [
    'extends',
    'tbResultsFolder',
    'inputFilePath',
    'outputFilePath',
];
const serverFileKeys = ['har', 'dist'];
// STEP 1
// takes a command flags object with all the flags the command accepts
// runs that commands object thru the defaults and returns those values
function getCommandDefaults(flags) {
    const f = flags;
    Object.entries(f).forEach(([key]) => {
        f[key] = default_flag_args_1.getDefaultValue(key) || flags[key];
    });
    // this will return a bunch of flags that don't have values
    // and wont know which are required or not
    return f;
}
/**
 * Read config file, expanding relative paths to absolute and
 * recursively reading extends
 * @param fileOrDir config file path or directory with a tbconfig.json
 */
function readConfig(fileOrDir = 'tbconfig.json') {
    let configDir;
    let configFile;
    let config;
    try {
        [configDir, configFile] = resolveConfigFile(fileOrDir);
        config = JSON5.parse(fs.readFileSync(configFile, 'utf8'));
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return;
        }
        throw e;
    }
    resolveConfigFileKeys(config, configDir);
    // extends is already absolute here from the above
    const parentConfigFile = config[tb_config_1.EXTENDS];
    if (parentConfigFile) {
        const parent = readConfig(parentConfigFile);
        if (parent === undefined) {
            throw new Error(`Extended config missing referenced in ${configFile}`);
        }
        const merged = utils_1.mergeLeft(parent, config);
        delete merged[tb_config_1.EXTENDS];
        return merged;
    }
    return config;
}
exports.readConfig = readConfig;
function resolveConfigFileKeys(config, configDir = process.cwd()) {
    resolveFileKeys(config, configFileKeys, configDir);
    if (Array.isArray(config.servers)) {
        for (const server of config.servers) {
            resolveFileKeys(server, serverFileKeys, configDir);
        }
    }
}
function resolveFileKeys(config, keys, configDir) {
    for (const key of keys) {
        const value = config[key];
        if (typeof value === 'string') {
            config[key] = path.resolve(configDir, value);
        }
    }
}
function resolveConfigFile(fileOrDir) {
    const resolved = path.resolve(fileOrDir);
    const stats = fs.statSync(resolved);
    let dir;
    let file;
    if (stats.isDirectory()) {
        dir = resolved;
        file = path.join(dir, 'tbconfig.json');
    }
    else {
        dir = path.dirname(resolved);
        file = resolved;
    }
    return [dir, file];
}
// overwrite all flags explicity flagged within cli command
function handleExplicitFlags(flags, explicitFlags) {
    const obj = {};
    const f = flags;
    explicitFlags.forEach(exF => {
        if (exF.startsWith('--') && !exF.includes('config')) {
            exF = exF.substring(2);
            obj[exF] = f[exF];
        }
    });
    return obj;
}
function getConfig(configFileOrDir = 'tbconfig.json', flags, explicitFlags) {
    const ef = handleExplicitFlags(flags, explicitFlags);
    resolveConfigFileKeys(ef);
    const commandDefaults = getCommandDefaults(flags);
    resolveConfigFileKeys(commandDefaults);
    const config = readConfig(configFileOrDir);
    if (config === undefined) {
        return utils_1.mergeLeft(commandDefaults, ef);
    }
    return utils_1.mergeLeft(utils_1.mergeLeft(commandDefaults, config), ef);
}
exports.getConfig = getConfig;
//# sourceMappingURL=build-config.js.map