"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const http = require("http");
const mimeTypes = require("mime-types");
const zlib = require("zlib");
class ArchiveServer {
    constructor(delegate) {
        this.delegate = delegate;
        this.responses = createMap();
    }
    loadArchive(path) {
        this.addArchive(JSON.parse(fs.readFileSync(path, 'utf8')));
    }
    addArchive(har) {
        this.addArchiveEntries(har.log.entries);
    }
    addArchiveEntries(entries) {
        for (const entry of entries) {
            this.addArchiveEntry(entry);
        }
    }
    addArchiveEntry(entry) {
        const key = this.delegate.keyForArchiveEntry(entry);
        if (!key) {
            return;
        }
        const response = this.buildResponseForArchiveEntry(entry, key);
        if (response) {
            this.addResponse(key, response);
        }
        else {
            // tslint:disable-next-line: no-console
            console.error(`unable to build response for key: ${key}`);
        }
    }
    buildResponseForArchiveEntry(entry, key) {
        const { status, content } = entry.response;
        if (content && status >= 200 && status < 300) {
            let { text } = content;
            const { encoding, mimeType } = content;
            let body;
            if (text === undefined) {
                body = undefined;
            }
            else if (mimeTypes.charset(mimeType) === 'UTF-8') {
                text = new Buffer(text, encoding).toString();
                if (this.delegate.textFor) {
                    text = this.delegate.textFor(entry, key, text);
                }
                body = new Buffer(text);
            }
            else {
                body = new Buffer(text, encoding);
            }
            const compress = content.compression !== undefined && content.compression > 0;
            let response = this.buildResponse(status, mimeType, body, compress);
            if (this.delegate.finalizeResponse) {
                response = this.delegate.finalizeResponse(entry, key, response);
            }
            return response;
        }
        if (this.delegate.responseFor) {
            return this.delegate.responseFor(entry, key);
        }
    }
    buildResponse(statusCode, mimeType, body, compress) {
        let headers;
        if (body && compress) {
            body = zlib.gzipSync(body, {
                level: 9,
            });
            headers = this.buildHeaders(mimeType, body, true);
        }
        else {
            headers = this.buildHeaders(mimeType, body, false);
        }
        return { statusCode, headers, body };
    }
    buildHeaders(mimeType, body, compressed) {
        const headers = {
            'Content-Length': '' + (body ? body.byteLength : 0),
            'Content-Type': mimeType,
        };
        if (compressed) {
            headers['Content-Encoding'] = 'gzip';
        }
        return headers;
    }
    addResponse(key, response) {
        // tslint:disable-next-line: no-console
        console.log(`add:  ${key}`);
        this.responses[key] = response;
    }
    setResponse(key, response) {
        // tslint:disable-next-line: no-console
        console.log(`set:  ${key}`);
        this.responses[key] = response;
    }
    responseFor(key) {
        return this.responses[key];
    }
    handle(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield Promise.resolve(this.delegate.keyForServerRequest(request));
            if (key) {
                const res = this.responseFor(key);
                if (res) {
                    // tslint:disable-next-line: no-console
                    console.log(`hit:  ${key}`);
                    response.writeHead(res.statusCode, res.headers);
                    response.end(res.body);
                }
                else {
                    // tslint:disable-next-line: no-console
                    console.log(`miss: ${key}`);
                }
            }
            if (this.delegate.missingResponse && !response.headersSent) {
                yield Promise.resolve(this.delegate.missingResponse(request, response));
            }
            if (!response.headersSent) {
                response.writeHead(404);
                response.end();
            }
            // tslint:disable-next-line: no-console
            console.log(response.statusCode, request.method, request.url);
        });
    }
    createServer() {
        return http.createServer((req, res) => this.handle(req, res));
    }
}
exports.default = ArchiveServer;
function createMap() {
    return Object.create(null);
}
//# sourceMappingURL=index.js.map